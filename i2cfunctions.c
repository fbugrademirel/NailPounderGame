#include <pic32mx.h>
#include <stdint.h>
#include <stdbool.h>
uint16_t temp;
uint16_t status = 0x1;
uint16_t status1 = 0x1;

////////////////////////////////////////////////////////////////
/////// THIS PART BELONGS TO PIC32- I2C RELATED FUNCTIONS //////
////////////////////////////////////////////////////////////////

/* i2c_wait function is used to wait for I2C bus to become idle:
    - Control register's first 5 bits to be 0 and;
    - Transmit buffer flag to be 0;
 
 This function is going to be called in other functions to provide enough time to control register to be set or transmit buffer to be freed.
 */
void i2c_wait() {
    while (I2C1CON & 0x1F || I2C1STAT & (1 << 14)); //TRSTAT
}

/* i2c_sendbyte function accepts the data to the transmit register and return ack/nack status of transaction: This function returns zero if ack status flag (if the data is received by the module) is one and returns 0 if the ack status flag is 1. This way it can be used in conjuction with start function().
 */
bool i2c_sendbyte(uint8_t data) {
    i2c_wait();
    I2C1TRN = data;
    i2c_wait();
    return !(I2C1STAT & (1 << 15)); //ACKSTAT
}

/* i2c_recievebyte function sets the receive buffer ON, clears the I2C receive overflow status bit
 and return the 8 bit value at receive register */
uint8_t i2c_receivebyte() {
    i2c_wait();
    I2C1CONSET = 1 << 3; //Receive Condition Enable Bit = 1
    i2c_wait();
    I2C1STATCLR = 1 << 6; //I2COV = 0
    return I2C1RCV;
}

/* i2c_ack function is used to send acknowledge conditon on the bus as MASTER. ACK data bit <5> is cleared to 0 and ACK sequence enable bit is set to 1.  */
void i2c_ack() {
    i2c_wait();
    I2C1CONCLR = 1 << 5; //ACKDT = 0
    I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* i2c_nack function is used to send not-acknowledge conditon on the bus as MASTER.ACK data bit <5> is set to 1 and ACK sequence enable bit is set to 1 also. */
void i2c_nack() {
    i2c_wait();
    I2C1CONSET = 1 << 5; //ACKDT = 1
    I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* i2c_start function is used initiate the start sequence on the bus by setting control register's <0> bit to 1 */
void i2c_start() {
    i2c_wait();
    I2C1CONSET = 1 << 0; //Start Condition Enable Bit
    i2c_wait();
}

/* i2c_restart is used restart conditon on the bus by setting control registers <1> bit to 1 */
void i2c_restart() {
    i2c_wait();
    I2C1CONSET = 1 << 1; //Restart Condition Enable Bit
    i2c_wait();
}

/* i2c_stop is used to send stop conditon on the bus  by setting control registers <2> bit to 1*/
void i2c_stop() {
    i2c_wait();
    I2C1CONSET = 1 << 2; //Stop Condition Enable Bit
    i2c_wait();
}

void i2c_initialize (){

    /*Clear every bit on Control Register */
    I2C1CON = 0x0;
    
    /* I2C Baud rate should be less than 400 kHz, is generated by dividing
     the 40 MHz peripheral bus clock down */
    I2C1BRG = 0x0C2;
    
    /*Clear every bit on flag status register*/
    I2C1STAT = 0x0;
    
    /*Set control register bit <13> to 1; For discontinueing module operation when device enters IDLE mode and set bit <15> to 1 to enable I2C */
    I2C1CONSET = 1 << 13; //SIDL = 1
    I2C1CONSET = 1 << 15; // ON = 1
    
    temp = I2C1RCV; //Clear receive buffer
    
    /* Set up input pins */
    TRISDSET = (1 << 8);
    TRISFSET = (1 << 1);
}


////////////////////////////////////////////////////////////////
///////// THIS PART BELONGS TO SENSOR RELATED FUNCTIONS ////////
////////////////////////////////////////////////////////////////


////////////////  FUNCTION TO INITITIALIZE SENSOR POWER MANAGEMENT //////////////////

void initsensor () {
    
//////////// CHECKING STANBY STATUS ///////////////
  
    while (!(((status) & 0x1f) == 0x0)) {
       
    
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));

        /* Send register number we want to access */
        i2c_sendbyte (0x06);

        do {
            i2c_start();
        } while (!i2c_sendbyte(((0x4C << 1) | 1)));

    
        status = i2c_receivebyte();
    
        i2c_nack();
        i2c_stop();
    
        timerdelay_ms (10);
    }
    
//////////// Drive INT_PAD high ///////////////
    
    do {
        i2c_start();
    } while (!i2c_sendbyte(0x4C << 1));
    
    /* Send register number we want to access */
    
    i2c_sendbyte(0x00); //reg adress
    
    i2c_sendbyte(0x04); //data
    
    i2c_stop();
   
//////////// Configure I2C interface ///////////////

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x1C); //reg adress
    
    i2c_sendbyte(0x65); //data
    
    i2c_stop();
    
//////////// Set initialization ///////////////

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x15); //reg adress
    
    i2c_sendbyte(0x05); //data
    
    i2c_stop();
    
//////////// Set MCPU OFF and CHECK STATUS ///////////////
    

    while (!(status == 0x10)) {
        
    //set MCPU OFF//
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        /* Send register number we want to access */
        
        i2c_sendbyte(0x04); //reg adress
        
        i2c_sendbyte(0x91); //data
        
        i2c_stop();
        
        //check//
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        
        /* Send register number we want to access */
        i2c_sendbyte(0x06);
        
        do {
            i2c_start();
        } while(!i2c_sendbyte(((0x4C << 1) |  1)));
        
        
        status = (i2c_receivebyte() & 0x1f);
        
        i2c_nack();
        i2c_stop();
        
        timerdelay_ms (10);
        
    }
    
//////////// Set initialization ///////////////
    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x15); //reg adress
    
    i2c_sendbyte(0x06); //data
    
    i2c_stop();
    
//////////// Set MCPU ON and CHECK STATUS ///////////////

    while (!(status == 0x01f8)) {
        
        //set MCPU ON//
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        /* Send register number we want to access */
        
        i2c_sendbyte(0x04); //reg adress
        
        i2c_sendbyte(0x92); //data
        
        i2c_stop();
        
        //check//
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        
        /* Send register number we want to access */
        i2c_sendbyte(0x06);
        
        do {
            i2c_start();
        } while(!i2c_sendbyte(((0x4C << 1) |  1)));
        
        status = i2c_receivebyte();
        i2c_ack();
        status |= (i2c_receivebyte()) << 8;
        
        i2c_nack();
        i2c_stop();
        
        timerdelay_ms (10);
    }
    
    
//////////// ToF Configuration ///////////////
    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x0C); //reg. adress
    
    i2c_sendbyte(0x00); //data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x0D); //reg. adress
    
    i2c_sendbyte(0xE1); //data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x0E); //reg. adress
    
    i2c_sendbyte(0xFF); //data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x0F); //reg. adress
    
    i2c_sendbyte(0x10); //data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x20);//reg. adress
    
    i2c_sendbyte(0xD0);//data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x21);//reg. adress
    
    i2c_sendbyte(0x07);//data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x22);//reg. adress
    
    i2c_sendbyte(0x08);//data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x23);//reg. adress
    
    i2c_sendbyte(0x50);//data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x24);//reg. adress
    
    i2c_sendbyte(0x41);//data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x25);//reg. adress
    
    i2c_sendbyte(0xA0);//data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x26);//reg. adress
    
    i2c_sendbyte(0xD4);//data
    
    i2c_stop();

    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x27);//reg. adress
    
    i2c_sendbyte(0x45);//data
    
    i2c_stop();

    
//////////// Stand-By State and CHECK STATUS ///////////////
    
    while (!(status == 0x00)) {
        
        //set MCPU Stand BY//
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        /* Send register number we want to access */
        
        i2c_sendbyte(0x04); //reg adress
        
        i2c_sendbyte(0x90); //data
        
        i2c_stop();
        
        //check//
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        
        /* Send register number we want to access */
        i2c_sendbyte(0x06);
        
        do {
            i2c_start();
        } while(!i2c_sendbyte(((0x4C << 1) |  1)));
        
        
        status = (i2c_receivebyte() & 0x1f);
        
        i2c_nack();
        i2c_stop();
        
        timerdelay_ms (10);
    }
}

////////////////  FUNCTION TO INITITIALIZE SINGLE MEASURE ///////////////////////

void single_measure_init(){
    
    
    //////////// Set initialization ///////////////
    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x15); //reg adress
    
    i2c_sendbyte(0x05); //data
    
    i2c_stop();
    
    //////////// Set MCPU OFF and CHECK STATUS ///////////////
    
    
    while (!(status == 0x10)) {
        
        //set MCPU OFF//
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        /* Send register number we want to access */
        
        i2c_sendbyte(0x04); //reg adress
        
        i2c_sendbyte(0x91); //data
        
        i2c_stop();
        
        //check//
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        
        /* Send register number we want to access */
        i2c_sendbyte(0x06);
        
        do {
            i2c_start();
        } while(!i2c_sendbyte(((0x4C << 1) |  1)));
        
        status = (i2c_receivebyte() & 0x1f);
        
        i2c_nack();
        i2c_stop();
        
        timerdelay_ms (10);
    }
    

    //////////// Set initialization ///////////////
    
    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x15); //reg adress
    
    i2c_sendbyte(0x06); //data
    
    i2c_stop();
    
    //////////// Set MCPU ON and CHECK STATUS ///////////////
    
    while (!(status == 0x01f8)) {
        
        //set MCPU ON//
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        /* Send register number we want to access */
        
        i2c_sendbyte(0x04); //reg adress
        
        i2c_sendbyte(0x92); //data
        
        i2c_stop();
        
        //check//
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        
        /* Send register number we want to access */
        i2c_sendbyte(0x06);
        
        do {
            i2c_start();
        } while(!i2c_sendbyte(((0x4C << 1) |  1)));
        
        
        status = i2c_receivebyte();
        i2c_ack();
        status |= (i2c_receivebyte()) << 8;
        
        i2c_nack();
        i2c_stop();
        
        timerdelay_ms (10);
    }
    
}

////////////////  FUNCTION TO RECEIVE SINGLE MEASURE ///////////////////////


uint16_t single_measure() {
    
    //Single Measure Command
    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x04);
    
    i2c_sendbyte(0x81);
    
    i2c_stop();
    
    //Read int Status Register to see if the data is ready
    
 while (!(status1 == 0x10)){
        
        do {
            i2c_start();
        } while(!i2c_sendbyte(0x4C << 1));
        
        /* Send register number we want to access */
        i2c_sendbyte(0x00);
        
        do {
            i2c_start();
        } while(!i2c_sendbyte(((0x4C << 1) |  1)));
        
            status1 = (i2c_receivebyte() & (1 << 4));
        
        i2c_nack();
        i2c_stop();
     
     timerdelay_ms (10);
     
    }
    //read result distance
    
    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x08);
    
    do {
        i2c_start();
    } while(!i2c_sendbyte(((0x4C << 1) |  1)));
    
    
    temp = i2c_receivebyte();
  
    i2c_ack();
    
    temp |= (i2c_receivebyte()) << 8;
    
    /* To stop receiving, send nack and stop */
    i2c_nack();
    i2c_stop();
    
    return ((temp & 0x1fff) >> 2);
}

void cameraoff(){
    
    status = 0x1;
    
    while (!(status == 0x00)) {

    //set MCPU off//
    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    /* Send register number we want to access */
    
    i2c_sendbyte(0x04); //reg adress
    
    i2c_sendbyte(0x90); //data
    
    i2c_stop();
    
    //check//
    do {
        i2c_start();
    } while(!i2c_sendbyte(0x4C << 1));
    
    /* Send register number we want to access */
    i2c_sendbyte(0x06);
    
    do {
        i2c_start();
    } while(!i2c_sendbyte(((0x4C << 1) |  1)));
    
    status = i2c_receivebyte() & 0x11;
    
    i2c_nack();
    i2c_stop();
    
    timerdelay_ms (10);
    
    }
}


